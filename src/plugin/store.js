/*
 * decaffeinate suggestions:
 * DS001: Remove Babel/TypeScript constructor workaround
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Public: The Store plugin can be used to persist annotations to a database
// running on your server. It has a simple customisable interface that can be
// implemented with any web framework. It works by listening to events published
// by the Annotator and making appropriate requests to the server depending on
// the event.
//
// The store handles five distinct actions "read", "search", "create", "update"
// and "destory". The requests made can be customised with options when the
// plugin is added to the Annotator. Custom headers can also be sent with every
// request by setting a $.data key on the Annotation#element containing headers
// to send. e.g:
//
//   annotator.element.data('annotation:headers', {
//     'X-My-Custom-Header': 'MyCustomValue'
//   })
//
// This header will now be sent with every request.
const Cls = (Annotator.Plugin.Store = class Store extends Annotator.Plugin {
  static initClass() {
    // The store listens for the following events published by the Annotator.
    // - annotationCreated: A new annotation has been created.
    // - annotationUpdated: An annotation has been updated.
    // - annotationDeleted: An annotation has been deleted.
    this.prototype.events = {
      'annotationCreated': 'annotationCreated',
      'annotationDeleted': 'annotationDeleted',
      'annotationUpdated': 'annotationUpdated'
    };
  
    // User customisable options available.
    this.prototype.options = {
  
      // Custom meta data that will be attached to every annotation that is sent
      // to the server. This _will_ override previous values.
      annotationData: {},
  
      // Should the plugin emulate HTTP methods like PUT and DELETE for
      // interaction with legacy web servers? Setting this to `true` will fake
      // HTTP `PUT` and `DELETE` requests with an HTTP `POST`, and will set the
      // request header `X-HTTP-Method-Override` with the name of the desired
      // method.
      emulateHTTP: false,
  
      // If loadFromSearch is set, then we load the first batch of
      // annotations from the 'search' URL as set in `options.urls`
      // instead of the registry path 'prefix/read'.
      //
      //     loadFromSearch: {
      //       'limit': 0,
      //       'all_fields': 1
      //       'uri': 'http://this/document/only'
      //     }
      loadFromSearch: false,
  
      // This is the API endpoint. If the server supports Cross Origin Resource
      // Sharing (CORS) a full URL can be used here.
      prefix: '/store',
  
      // The server URLs for each available action. These URLs can be anything but
      // must respond to the appropraite HTTP method. The token ":id" can be used
      // anywhere in the URL and will be replaced with the annotation id.
      //
      // read:    GET
      // create:  POST
      // update:  PUT
      // destroy: DELETE
      // search:  GET
      urls: {
        create:  '/annotations',
        read:    '/annotations/:id',
        update:  '/annotations/:id',
        destroy: '/annotations/:id',
        search:  '/search'
      }
    };
  }

  // Public: The contsructor initailases the Store instance. It requires the
  // Annotator#element and an Object of options.
  //
  // element - This must be the Annotator#element in order to listen for events.
  // options - An Object of key/value user options.
  //
  // Examples
  //
  //   store = new Annotator.Plugin.Store(Annotator.element, {
  //     prefix: 'http://annotateit.org',
  //     annotationData: {
  //       uri: window.location.href
  //     }
  //   })
  //
  // Returns a new instance of Store.
  constructor(element, options) {
    {
      // Hack: trick Babel/TypeScript into allowing this before super.
      if (false) { super(); }
      let thisFn = (() => { return this; }).toString();
      let thisName = thisFn.slice(thisFn.indexOf('return') + 6 + 1, thisFn.indexOf(';')).trim();
      eval(`${thisName} = this;`);
    }
    this._getAnnotations = this._getAnnotations.bind(this);
    this._onLoadAnnotations = this._onLoadAnnotations.bind(this);
    this._onLoadAnnotationsFromSearch = this._onLoadAnnotationsFromSearch.bind(this);
    this._onError = this._onError.bind(this);
    super(...arguments);
    this.annotations = [];
  }

  // Public: Initialises the plugin and loads the latest annotations. If the
  // Auth plugin is also present it will request an auth token before loading
  // any annotations.
  //
  // Examples
  //
  //   store.pluginInit()
  //
  // Returns nothing.
  pluginInit() {
    if (!Annotator.supported()) { return; }

    if (this.annotator.plugins.Auth) {
      return this.annotator.plugins.Auth.withToken(this._getAnnotations);
    } else {
      return this._getAnnotations();
    }
  }

  // Checks the loadFromSearch option and if present loads annotations using
  // the Store#loadAnnotationsFromSearch method rather than Store#loadAnnotations.
  //
  // Returns nothing.
  _getAnnotations() {
    if (this.options.loadFromSearch) {
      return this.loadAnnotationsFromSearch(this.options.loadFromSearch);
    } else {
      return this.loadAnnotations();
    }
  }

  // Public: Callback method for annotationCreated event. Receives an annotation
  // and sends a POST request to the sever using the URI for the "create" action.
  //
  // annotation - An annotation Object that was created.
  //
  // Examples
  //
  //   store.annotationCreated({text: "my new annotation comment"})
  //   # => Results in an HTTP POST request to the server containing the
  //   #    annotation as serialised JSON.
  //
  // Returns nothing.
  annotationCreated(annotation) {
    // Pre-register the annotation so as to save the list of highlight
    // elements.
    if (!Array.from(this.annotations).includes(annotation)) {
      this.registerAnnotation(annotation);

      return this._apiRequest('create', annotation, data => {
        // Update with (e.g.) ID from server.
        if ((data.id == null)) {
          console.warn(Annotator._t("Warning: No ID returned from server for annotation "), annotation);
        }
        return this.updateAnnotation(annotation, data);
      });
    } else {
      // This is called to update annotations created at load time with
      // the highlight elements created by Annotator.
      return this.updateAnnotation(annotation, {});
    }
  }

  // Public: Callback method for annotationUpdated event. Receives an annotation
  // and sends a PUT request to the sever using the URI for the "update" action.
  //
  // annotation - An annotation Object that was updated.
  //
  // Examples
  //
  //   store.annotationUpdated({id: "blah", text: "updated annotation comment"})
  //   # => Results in an HTTP PUT request to the server containing the
  //   #    annotation as serialised JSON.
  //
  // Returns nothing.
  annotationUpdated(annotation) {
    if (Array.from(this.annotations).includes(annotation)) {
      return this._apiRequest('update', annotation, (data => this.updateAnnotation(annotation, data)));
    }
  }

  // Public: Callback method for annotationDeleted event. Receives an annotation
  // and sends a DELETE request to the server using the URI for the destroy
  // action.
  //
  // annotation - An annotation Object that was deleted.
  //
  // Examples
  //
  //   store.annotationDeleted({text: "my new annotation comment"})
  //   # => Results in an HTTP DELETE request to the server.
  //
  // Returns nothing.
  annotationDeleted(annotation) {
    if (Array.from(this.annotations).includes(annotation)) {
      return this._apiRequest('destroy', annotation, (() => this.unregisterAnnotation(annotation)));
    }
  }

  // Public: Registers an annotation with the Store. Used to check whether an
  // annotation has already been created when using Store#annotationCreated().
  //
  // NB: registerAnnotation and unregisterAnnotation do no error-checking/
  // duplication avoidance of their own. Use with care.
  //
  // annotation - An annotation Object to resister.
  //
  // Examples
  //
  //   store.registerAnnotation({id: "annotation"})
  //
  // Returns registed annotations.
  registerAnnotation(annotation) {
    return this.annotations.push(annotation);
  }

  // Public: Unregisters an annotation with the Store.
  //
  // NB: registerAnnotation and unregisterAnnotation do no error-checking/
  // duplication avoidance of their own. Use with care.
  //
  // annotation - An annotation Object to unresister.
  //
  // Examples
  //
  //   store.unregisterAnnotation({id: "annotation"})
  //
  // Returns remaining registed annotations.
  unregisterAnnotation(annotation) {
    return this.annotations.splice(this.annotations.indexOf(annotation), 1);
  }

  // Public: Extends the provided annotation with the contents of the data
  // Object. Will only extend annotations that have been registered with the
  // store. Also updates the annotation object stored in the 'annotation' data
  // store.
  //
  // annotation - An annotation Object to extend.
  // data       - An Object containing properties to add to the annotation.
  //
  // Examples
  //
  //   annotation = $('.annotation-hl:first').data('annotation')
  //   store.updateAnnotation(annotation, {extraProperty: "bacon sarnie"})
  //   console.log($('.annotation-hl:first').data('annotation').extraProperty)
  //   # => Outputs "bacon sarnie"
  //
  // Returns nothing.
  updateAnnotation(annotation, data) {
    if (!Array.from(this.annotations).includes(annotation)) {
      console.error(Annotator._t("Trying to update unregistered annotation!"));
    } else {
      $.extend(annotation, data);
    }

    // Update the elements with our copies of the annotation objects (e.g.
    // with ids from the server).
    return $(annotation.highlights).data('annotation', annotation);
  }

  // Public: Makes a request to the server for all annotations.
  //
  // Examples
  //
  //   store.loadAnnotations()
  //
  // Returns nothing.
  loadAnnotations() {
    return this._apiRequest('read', null, this._onLoadAnnotations);
  }

  // Callback method for Store#loadAnnotations(). Processes the data
  // returned from the server (a JSON array of annotation Objects) and updates
  // the registry as well as loading them into the Annotator.
  //
  // data - An Array of annotation Objects
  //
  // Examples
  //
  //   console.log @annotation # => []
  //   store._onLoadAnnotations([{}, {}, {}])
  //   console.log @annotation # => [{}, {}, {}]
  //
  // Returns nothing.
  _onLoadAnnotations(data) {

    if (data == null) { data = []; }
    const annotationMap = {};
    for (var a of Array.from(this.annotations)) {
      annotationMap[a.id] = a;
    }

    const newData = [];
    for (a of Array.from(data)) {
      if (annotationMap[a.id]) {
        const annotation = annotationMap[a.id];
        this.updateAnnotation(annotation, a);
      } else {
        newData.push(a);
      }
    }

    this.annotations = this.annotations.concat(newData);
    return this.annotator.loadAnnotations(newData.slice()); // Clone array
  }

  // Public: Performs the same task as Store.#loadAnnotations() but calls the
  // 'search' URI with an optional query string.
  //
  // searchOptions - Object literal of query string parameters.
  //
  // Examples
  //
  //   store.loadAnnotationsFromSearch({
  //     limit: 100,
  //     uri: window.location.href
  //   })
  //
  // Returns nothing.
  loadAnnotationsFromSearch(searchOptions) {
    return this._apiRequest('search', searchOptions, this._onLoadAnnotationsFromSearch);
  }

  // Callback method for Store#loadAnnotationsFromSearch(). Processes the data
  // returned from the server (a JSON array of annotation Objects) and updates
  // the registry as well as loading them into the Annotator.
  //
  // data - An Array of annotation Objects
  //
  // Returns nothing.
  _onLoadAnnotationsFromSearch(data) {
    if (data == null) { data = {}; }
    return this._onLoadAnnotations(data.rows || []);
  }

  // Public: Dump an array of serialized annotations
  //
  // param - comment
  //
  // Examples
  //
  //   example
  //
  // Returns
  dumpAnnotations() {
    return (Array.from(this.annotations).map((ann) => JSON.parse(this._dataFor(ann))));
  }

  // Callback method for Store#loadAnnotationsFromSearch(). Processes the data
  // returned from the server (a JSON array of annotation Objects) and updates
  // the registry as well as loading them into the Annotator.
  // Returns the jQuery XMLHttpRequest wrapper enabling additional callbacks to
  // be applied as well as custom error handling.
  //
  // action    - The action String eg. "read", "search", "create", "update"
  //             or "destory".
  // obj       - The data to be sent, either annotation object or query string.
  // onSuccess - A callback Function to call on successful request.
  //
  // Examples:
  //
  //   store._apiRequest('read', {id: 4}, (data) -> console.log(data))
  //   # => Outputs the annotation returned from the server.
  //
  // Returns jXMLHttpRequest object.
  _apiRequest(action, obj, onSuccess) {
    const id  = obj && obj.id;
    const url = this._urlFor(action, id);
    const options = this._apiRequestOptions(action, obj, onSuccess);

    const request = $.ajax(url, options);

    // Append the id and action to the request object
    // for use in the error callback.
    request._id = id;
    request._action = action;
    return request;
  }

  // Builds an options object suitable for use in a jQuery.ajax() call.
  //
  // action    - The action String eg. "read", "search", "create", "update"
  //             or "destory".
  // obj       - The data to be sent, either annotation object or query string.
  // onSuccess - A callback Function to call on successful request.
  //
  // Also extracts any custom headers from data stored on the Annotator#element
  // under the 'annotator:headers' key. These headers should be stored as key/
  // value pairs and will be sent with every request.
  //
  // Examples
  //
  //   annotator.element.data('annotator:headers', {
  //     'X-My-Custom-Header': 'CustomValue',
  //     'X-Auth-User-Id': 'bill'
  //   })
  //
  // Returns Object literal of $.ajax() options.
  _apiRequestOptions(action, obj, onSuccess) {
    const method = this._methodFor(action);

    let opts = {
      type:       method,
      headers:    this.element.data('annotator:headers'),
      dataType:   "json",
      success:    (onSuccess || function() {}),
      error:      this._onError
    };

    // If emulateHTTP is enabled, we send a POST and put the real method in an
    // HTTP request header.
    if (this.options.emulateHTTP && ['PUT', 'DELETE'].includes(method)) {
      opts.headers = $.extend(opts.headers, {'X-HTTP-Method-Override': method});
      opts.type = 'POST';
    }

    // Don't JSONify obj if making search request.
    if (action === "search") {
      opts = $.extend(opts, {data: obj});
      return opts;
    }

    const data = obj && this._dataFor(obj);

    // If emulateJSON is enabled, we send a form request (the correct
    // contentType will be set automatically by jQuery), and put the
    // JSON-encoded payload in the "json" key.
    if (this.options.emulateJSON) {
      opts.data = {json: data};
      if (this.options.emulateHTTP) {
        opts.data._method = method;
      }
      return opts;
    }

    opts = $.extend(opts, {
      data,
      contentType: "application/json; charset=utf-8"
    });
    return opts;
  }

  // Builds the appropriate URL from the options for the action provided.
  //
  // action - The action String.
  // id     - The annotation id as a String or Number.
  //
  // Examples
  //
  //   store._urlFor('update', 34)
  //   # => Returns "/store/annotations/34"
  //
  //   store._urlFor('search')
  //   # => Returns "/store/search"
  //
  // Returns URL String.
  _urlFor(action, id) {
    let url = (this.options.prefix != null) ? this.options.prefix : '';
    url += this.options.urls[action];
    // If there's a '/:id' in the URL, either fill in the ID or remove the
    // slash:
    url = url.replace(/\/:id/, (id != null) ? `/${id}` : '');
    // If there's a bare ':id' in the URL, then substitute directly:
    url = url.replace(/:id/, (id != null) ? id : '');

    return url;
  }

  // Maps an action to an HTTP method.
  //
  // action - The action String.
  //
  // Examples
  //
  //   store._methodFor('read')    # => "GET"
  //   store._methodFor('update')  # => "PUT"
  //   store._methodFor('destroy') # => "DELETE"
  //
  // Returns HTTP method String.
  _methodFor(action) {
    const table = {
      'create':  'POST',
      'read':    'GET',
      'update':  'PUT',
      'destroy': 'DELETE',
      'search':  'GET'
    };

    return table[action];
  }

  // Creates a JSON serialisation of an annotation.
  //
  // annotation - An annotation Object to serialise.
  //
  // Examples
  //
  //   store._dataFor({id: 32, text: 'my annotation comment'})
  //   # => Returns '{"id": 32, "text":"my annotation comment"}'
  //
  // Returns
  _dataFor(annotation) {
    // Store a reference to the highlights array. We can't serialize
    // a list of HTMLElement objects.
    const { highlights } = annotation;

    delete annotation.highlights;

    // Preload with extra data.
    $.extend(annotation, this.options.annotationData);
    const data = JSON.stringify(annotation);

    // Restore the highlights array.
    if (highlights) { annotation.highlights = highlights; }

    return data;
  }

  // jQuery.ajax() callback. Displays an error notification to the user if
  // the request failed.
  //
  // xhr - The jXMLHttpRequest object.
  //
  // Returns nothing.
  _onError(xhr) {
    const action  = xhr._action;
    let message = Annotator._t("Sorry we could not ") + action + Annotator._t(" this annotation");

    if (xhr._action === 'search') {
      message = Annotator._t("Sorry we could not search the store for annotations");
    } else if ((xhr._action === 'read') && !xhr._id) {
      message = Annotator._t("Sorry we could not ") + action + Annotator._t(" the annotations from the store");
    }

    switch (xhr.status) {
      case 401: message = Annotator._t("Sorry you are not allowed to ") + action + Annotator._t(" this annotation"); break;
      case 404: message = Annotator._t("Sorry we could not connect to the annotations store"); break;
      case 500: message = Annotator._t("Sorry something went wrong with the annotation store"); break;
    }

    Annotator.showNotification(message, Annotator.Notification.ERROR);

    return console.error(Annotator._t("API request failed:") + ` '${xhr.status}'`);
  }
});
Cls.initClass();
